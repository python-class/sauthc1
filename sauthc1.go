// Copyright (c) 2012 Jason McVetta.  This is Free Software, released under the 
// terms of the GPL v3.  See http://www.gnu.org/copyleft/gpl.html for details.

// Package sauthc1 implements the SAuthc1 Stormpath cryptographic digest
// authentication algorithm.
package sauthc1

// This code was inspired by the official Stormpath Ruby and Java algos:
//     https://github.com/stormpath/stormpath-sdk-ruby/blob/master/lib/stormpath-sdk/http/authc/sauthc1_signer.rb
//     https://github.com/stormpath/stormpath-sdk-java/blob/master/impl/src/main/java/com/stormpath/sdk/impl/http/authc/Sauthc1Signer.java

import (
	"crypto/rand"
	"math"
	"math/big"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
	// "encoding/base64"
	"github.com/jmcvetta/guid"
	// "github.com/jmcvetta/randutil"
)

type ApiKey string

type Sauthc1Signer struct {
	DefaultAlgorithm     string
	HostHeader           string
	AuthorizationHeader  string
	StorpathDateHeader   string
	IdTerminator         string
	Algorithm            string
	AuthenticationScheme string
	Sauthc1Id            string
	Sauthc1SignedHeaders string
	Sauthc1Signature     string
	DateFormat           string
	TimestampFormat      string
	Newline              string
	GuidGenerator        guid.Generator
}

// DefaultSigner returns a new Sauthc1Signer object initialized with the default
// values.
func DefaultSigner() Sauthc1Signer {
	s := Sauthc1Signer{
		DefaultAlgorithm:     "SHA256",
		HostHeader:           "Host",
		AuthorizationHeader:  "Authorization",
		StorpathDateHeader:   "X-Stormpath-Date",
		IdTerminator:         "sauthc1_request",
		Algorithm:            "HMAC-SHA-256",
		AuthenticationScheme: "SAuthc1",
		Sauthc1Id:            "sauthc1Id",
		Sauthc1SignedHeaders: "sauthc1SignedHeaders",
		Sauthc1Signature:     "sauthc1Signature",
		DateFormat:           "%Y%m%d",
		TimestampFormat:      "%Y%m%dT%H%M%SZ",
		Newline:              "\n",
		GuidGenerator:        guid.SimpleGenerator(),
	}
	return s
}

// nonce returns concatenated string representations of a guid, generated by a
// snowflake algorithm, and a random integer.
//
// Note:  I have no fucking clue if this is a cryptographically secure nonce.  I
// think it might be, but you really shouldn't rely on that.
func (s *Sauthc1Signer) nonce() (string, error) {
	var result string
	// GUID
	i, err := s.GuidGenerator.NextId()
	if err != nil {
		return result, err
	}
	result = strconv.FormatInt(i, 10)
	// Random Int64
	b, err := rand.Int(rand.Reader, big.NewInt(math.MaxInt64))
	result += strconv.FormatInt(b.Int64(), 10)
	return result, nil // Success!
}

func (s *Sauthc1Signer) Sign(req *http.Request, key ApiKey) error {
	now := time.Now()
	timeStamp := now.Format(s.TimestampFormat)
	dateStamp := now.Format(s.DateFormat)
	nonce, err := s.nonce()
	if err != nil {
		return err
	}
	url := req.URL
	host := url.Host
	/*
	In the Ruby version of this algorithm, we see the following code to check
	default port and append append the port if unspecified.
	
          host_header = uri.host
          if !RequestUtils.default_port?(uri)

            host_header << ":" << uri.port.to_s
          end
          
	It appears this is required because Ruby's URI module splits host and port into
	seperate variables.  Go keeps them as a single string, so I do not this this
	will be necessary.
	*/
	req.Header.Add(s.HostHeader, host)
	return nil // Success!
}


// defaultPort checks whether a URL contains the default port for its scheme: 80
// for http, 443 for https, or no port specified.
func defaultPort(u *url.URL) bool {
	scheme := u.Scheme
	parts := strings.Split(u.Host, ":")
	var port string
	switch len(parts) {
		case 1:
			port = ""
		case 2:
			port = parts[1]
		default:
			// Would it be better to return an error here?
			return false
	}
	result := port == "" || port == "0" || (port == "80" && scheme == "http") || (port == "443" && scheme == "https")
	return result // Success!
}
